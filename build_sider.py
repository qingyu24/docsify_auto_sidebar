import gzip
import os

INDEX_HTML = b'\x1f\x8b\x08\x00n\xa6+e\x02\xff\xb5X\xffo\xd3F\x14\xff\x99\xfe\x15\x877)\xed\x88m\xda1\xb4\x95\xa4\xeaV\xba\r\x89\x01\x12E\xda\x04h\xba\xd8\xd7\xf8Z\xdbg|N\xda2U\xa2\x1a\x0c(_Z\x06\xe5;j\x0b\x9d`e\x94\x0e\x18\x14Z\xba\x7f&N\x9a\xdf\xf6\'\xec\xd9I\xfc%M\xbbAhT\xa7\xf6{w\xef\xf3\xb9w\xef\xdd{Nj\xbb("j\xaadX\xd2\x1cCG\xa2\xd8\xd5\xd2\x92\xda\xbe\xf7`O\xdf\x0f\x87z\x91\'\xebjIU\xfe!\x94\xd2\x08V\xbd\x1b\xb85\x88\x83A\xefX"9\x91\xa3\xf9\xb4\xf0\xbdx\xe4K\xb1\x87\x19\x16vhF\'\x02R\x98\xe9\x10\xd3I\x0b\xfbz\xd3D\xcd\x92\xa4\xa2\xd9\xcc \xe9v\x01\xc9Q#&\x06\xa1\x90\xa7d\xc8b\xb6\x13\x997DUGK\xab$O\x15"\xfa\x0fIjR\x87b]\xe4\n\xd6\xd7[R4ls\x023\x8f\xf4}-~\x1e*uj\x0e"\x9b\xe8i\x81;#:\xe1\x1a!\x80\xa3\xd9\xa4?-\xc8\xb2\xa2\x9a\xd2\x00W\x89N\xf3\xb6d\x12G6-CV\x99\xc2i\xffH\xf7.\xd9\xd1\x88A\xb8\x9c\xcf\x11I\xe1\xdc7Z\xb1\xea\xb9\xaex\xfdla\xf9\xa5;\xf7\xba8\xf3\xca]\x99\xf0\xfd\xd7$\xa4\xc8\xa9J2\xd8\x16\x15\xa6\xeb\xd8\xe2DV)w\xe4\x9a\xb4\x9f\xe9*\xb1%\x83\x9a\x01\x9d\x80Mi\xe1\x89;\xf7\xa2\x8eJE\xb5e\x84\xa2L\xaa\x98)\xb9\x16\'\xa9\x0cSG\xaa\x04M\x9c\xaf\x12B)\\\x05\xfeH\x16\xbaz\x0f\xa4d\xdc@\xa30\x95\x9aY\x18\x007$\x18\x92\x92\x03;)\x95\xe6\x11U\xd3\x02\xb6,\xa1+\x05\xacj\n\xae\xd8\xd4r\xba\x10\xaaZ\x1d\x82\x08gC\xd2\xc7\xd5\x05\xa14\xfa\xa9\xaaA~\xf4u"\xa1|\xef\xd7\xf2\x9f+_\xe9,+$c\xba\xfd\x9e\xdf:=\xa6\xa1\\\x96Qa\xf5\xe1\xda*\xec\xfa\x04D@q\xf6A\xe9\xce\x82\xfbv*\x18\xa03\xac\x1e\xae\xf8\xa7\x139v\x8e$[\x02\x1d\xcfe\xbe\xc3\xc3\xfbI\x9e\xe8\x9dhWh\x14\xeb\x14\xf3\xce\x083\x84\x04Y\xfaD\xfe1p\xb4*\x00\xd1\xd8s8{4\xc6n\xed\xd5\xf3\xb5\xb7\x7f\xb8\x93\x97\xd7\xce\xce\xbb\xe3\x8f\xdcs\x8b\xe5\xd9\x97\xe5\x9f\x1f\x85`9\x87u8\xcc\xaa\xb1\x8b\xccuWN\xb9\x93O\xdd\xc5\xb1\xf2\xbd\xfbQ\xb9\xc2\xf2\xc4\xb6p\x96\xac[\x11(\x0f\xed?\xf2\xcd\xbe\x03\x87\xa3"\xb1\xc9O\xd4Vy\xf6/`\xe3N<\x07\xb7;L\tTp\x1f\xf7\x18\x08B\xe7v$\xa3\x1alg\x89\x03\x0e\xd4:\x92H\xfb\x14\xae]p}\x06\xd7\xee\xb8\x1bc\xbe8\xf3\xc8\xdb\xdf\xc9\xbb\xa5\x17\xa1/8\xc1\xb6\xa2\xc5qUb9 \xda\x1dE4\xd9^\xec`@,>\x9b-\xde=\x0fV`\x1f\xb6\x0b\xd1!\x96\x8e\x15\xa2\xf9\x19\xed\x8d\xf3q$I\x8a\x8d\xf1\x96?\xf6\xb7{\xe6RE\r\x7f\xee\xca\x94\xfb\xcb\xb3\xd2\xfcX\xd2\x9d\xbcXX:\xe5NO\x17\x96.\x94n\x9fv\xe7n\x17\x96\xe6Ko\xaf\x94\x1e\xdf*\xbc\xbeP\xbe\xf1"J\x07\x82\x99[\x80\x07HC$\xc3\xa9C\xc4\xf6\r#\xc8}3\x05\xf1\xe2>]Y;7\x1f\xc8a\xf7\xa9\t\xc7;3\xe3\xab\xb7l8\xa3Y\x8e\xf7\x91a\xcf\xc3\x85\xa5q`\x05{\x16[\x87\t\xca`\xc0\x85\x06\x03\x14\x9bq\xde\xa3a\xcb!v}\\\xc6\xb5\x153\xf1\x11u\xf4\x9f\xdc(N-\x96\x96\xa7\xd7\x16f\x03\xb9\xc2r\xa6\x13g\xee\x8b0\x94\xab\xf5\x80\x16\x03\x17\xf9K\x15 QbL\r\x88%\xea)\xdawZ\xc31M?d\xbe\xb7B\x9bf5\'\xae\x81\xaa\xc6\xe9I\xcf\xfb;\xa5/\x88\x11_:\xd3\x99\x17\x016Qcr\x1d\x9b\xd9\x9c\x9fr\x82\xa2Q\x93p\x12W3(\x83\xf4d\x83\x1d\x813\x8f\xd9*\x1c\'Bl\x02P\xa7f\xce!\xf5\xf2\xd1\xe8\x03\xe5\xbd\xc3\x16Q\x1c\xa2n\xe2cK\xcf\x81\x0b\x00\xe0h\x0b\xea\xcf\x99\x8aG\xa1Ucl0\x89\xf2F[\xc0\xc5\x93H\x19\xd2\xcfl\xd2\x8b\x15\xad5\x1c\n-E[\x842\xec\x19\xec\x16DE\xf1\xd5\xb2;>SZ\xb9\xbe\xb6z\xa5|u\xb5x\xf9\xb7`L\x1e\xdb(g\xeb(\x1d!\x9b\x90\x13hG\xe49oH6\x83\x15J\xfdT\'{\x02\x85_\x03\xbd\xf9D\xa5\xce\xb7^\xa7\x93F\x89\xa3\xffL_\xbd\x87\xca\xf7O\x97\xa6nU\x00\x8f\xb7\x825\x1fc\x07J\xb4\x1d3\x13{\xc22\n\x9f\xda\xe4t"\x11\x9a\xb6\x89\x93\xb3M\xd4\x1a!\x11\x80D\x99i\xf5\x82\xc41\xd3;\xe7\x00%\x10\xb6\xd5\xcc\x8eV\xefF\xfd\x1av\xbc&\xddS\xad\x81\xd5\x02\x17V\xfeZe\x0b\xfa\x8f\xca\x08\xc4m%-x]\x1a\xef\xfc\xcfFG\xa7\x99\xda\x93_\xd4\x07\xb8WU\xc3Z\x1a\xa2\x15\x96\x1f\x94f\xc6\xca\x8fo\x16\xde, \xb4\xa9y\xcb\xa6\xdc\x18\xe0\xdd\xedP\xcf\r\x8b\x99\xd0\xd8q\xd9\xa7\xb9\xed\x1d\x896\xb4\xe4\x0bE~B\x8f\xb3]o\xfa\xdd\x8df0\xd7\xd6\xfba\xdb\x870m\x8d8\x1a3\xd7\x1b\xff\x10\xb6\x15\x03\x0f\x92\xad1=\x80\xf3x\x8bHs\xe8\xdc\xadFQ\x87\xaaM\\\x93\x00\x10\xd7\x83\xd5\xae\xb9>\xac\xb75\xbb\x99l\x88\xd8\xd0N\xebz\xe3\xac\t\xd3\x06\xca3\xd4\x9a\xe2\xb5\xa7\xc5\x8bc\xef\x9f\xa9"\xd8\xf0\x88\xf8MxT\xd6`k\xeaS\xd6\x9d\xbb\xe4\x9e{\xd9\x04\xb6\xc2,\xefK%\xdd\x1dq\x02\x81bS\x16\x95\xae\x02\x05\rB\xd0\x084A)lJ\xea9\x85\x9a\rI\xbd\xe71Y\xad~2\xf4!\xc46\xfd\xf7Q\xcf\xceV\xc1d\xf1\xe6^\x8dt\xa9MW\x80\x1af\xa5\xcb\xdd\x18\xf3\xcej\xe9\xfc\xd9\xe2\xb5Uw\xeeai\xe5wwq\xe2\x83!\x9fd\xcc\x10\xa9\x01m\xcf\xe6\xab\x8e\xb4xME4t\x80\xdd:v\x88\x179^\xf8\x04=\xe1\xe6\tU{\x01\xac\xbc\xfa\x15\xc7o\xba\x133M\xf0h\xfc\x92\xbd\x91vSj\xd1\xb7%\xd4w\xb0\xa7\x99\xe4\xf2\xf7D\x84\xd7\xaa\xeev\xa9]\xdaY\x97`\x81v#>UF\xc4`\x034\xd2J\xfd\x9f#\xb7\n\x12\xcf7\xcfN\xc3\x12\x94\x92+?5\xa4\xe4\xca\x8fU\xff\x02\xd0\xcf\x91\x0c\xd9\x12\x00\x00'
INDEDX_PATH = 'index.html'
OVERWRITE_README = True
# 敏感词
SENSITIVE_WORDS = ['.git', '.gitignore', 'node_modules',"生活记录",
                   'package-lock.json', 'package.json', 'build_sider.py']


def noSpace(string):

    if string.startswith('./'):
        string = string[2:]
    return string.replace(" ", "%20")


def get_last_path(f):
    ps = pathes(f)
    if len(ps) < 2:
        return ''
    if ps[-2] == '':
        return ps[-3]
    return ps[-2]


def pathes(f):
    if f.startswith('./'):
        f = f[2:]
    return f.split('/')


def write_back_line(dir_path):
    pn = get_last_path(dir_path)
    if dir_path == './':
        return ""
    if pn == '':
        content_rm = f"< [上一级](README.md) \n\n"
    else:
        last_path = dir_path.split(pathes(dir_path)[-1])[0]
        content_rm = f"< [{pn}]({last_path}) \n\n"
    return content_rm


def write_readme(file_list, dir_path):
    if not OVERWRITE_README and os.path.exists(os.path.join(dir_path, "README.md")):
        print(f"{dir_path}下存在README.md文件，跳过")
        return
    with open(os.path.join(dir_path, "README.md"), "w") as file:
        # 查看第一行空格数 将每一行都删除同样的空格数
        space_num = len(file_list[0]) - len(file_list[0].lstrip())
        file.write(write_back_line(dir_path))
        for line in file_list:
            # 将入处理 避免index out of range
            if len(line) > space_num:
                file.write(line[space_num:])
            else:
                file.write(line)


def generate_md_files(dir_path, depth, file):
    file_list = []
    items = os.listdir(dir_path)
    # 对items排序，文件夹在前，文件在后 同样的安装字母排序升序
    items.sort(key=lambda x: (not os.path.isdir(
        os.path.join(dir_path, x)), x.lower()))
    # 如果目录下没有有效的md文件 去掉目录
    for item in items:
        # 将当前目录下的信息汇总，先缓存到list中
        if item.startswith(".") or item.startswith("_"):
            continue
        item_path = noSpace(os.path.join(dir_path, item))
        #item 是个完全目录 如果item任意一级目录在SENSITIVE_WORDS去掉相关目录
        if any(word in item_path.split('/') for word in SENSITIVE_WORDS):
            continue
        if os.path.isdir(item_path):

            tmp_item = generate_md_files(item_path, depth + 1, file)
            if len(tmp_item) > 0:
                file_list.append(f"{'  ' * depth}- [{item}]({item_path}/)\n")
                file_list.extend(tmp_item)
        elif item.endswith(".md") and item != "README.md":
            # 处理.md只保留文件名
            item = item.replace(".md", "")
            file_list.append(f"{'  ' * depth}- [{item}]({item_path})\n")
    # 将缓存的信息写入到文件中
    if len(file_list) == 0:
        return []
    write_readme(file_list, dir_path)
    return file_list


def read_file_as_bytes(file_path):
    """读取文件并保存成字节形式

    Args:
        file_path (_type_): _description_

    Returns:
        _type_: _description_
    """
    with open(file_path, "rb") as file:
        file_content = file.read()
    compressed_code = gzip.compress(file_content)
    return compressed_code

# 读取文件并转换为字节形式
# file_bytes = read_file_as_bytes("index.html")
#  print(file_bytes)


def write_file_from_bytes(file_path, file_bytes):
    """将字节形式的文件内容写入文件

    Args:
        file_path (_type_): _description_
        file_bytes (_type_): _description_
    """
    decompressed_code = gzip.decompress(file_bytes)
    with open(file_path, "wb") as file:
        file.write(decompressed_code)


# 检查文件是否存在 不在则创建
def check_index_html():
    """
    检查文件是否存在，不存在则创建
    """
    if not os.path.exists(INDEDX_PATH):
        print("初始化 index.html。如需定制请自行修改")
        write_file_from_bytes(INDEDX_PATH, INDEX_HTML)


def main():
    dir_path = "./"
    check_index_html()
    with open(os.path.join(dir_path,  "_sidebar.md"), "w") as file:
        for i in generate_md_files(dir_path, 0, file):
            file.write(i)

    
    
if __name__ == "__main__":
    OVERWRITE_README = input("是否全部覆盖README.md文件？(y/n)") == 'y'
    if OVERWRITE_README:
        print("将覆盖所有README.md文件")
    main()
    print("完成目录编辑更新")


# 读取文件并转换为字节形式
# file_bytes = read_file_as_bytes("index.html")
# print(file_bytes)


# //测试命令python -m http.server 3000

